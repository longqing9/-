---
title: 垃圾回收器
date: 2021-01-16 16:37:34
tags: [垃圾回收机制]
categories: java虚拟机
---

一、java堆内存的“分代”概念

在java虚拟机中，堆内存被划分新生代，老年代和持久代三部分。新生代被划分为Eden区、Survivor/S0区和Survivor/S1区。和具体划分如下：

![堆内存分代图](E:\blog\source\images\2021011801.png)

二、GC的类型

***因为业界没有统一的严格意义上的界限，也没有严格意义上的GC类型***

在java虚拟机进行垃圾收集(GC)时，一般将其分为两种：次收集(Minor GC/young GC)和全收集(Full GC)。

1、触发时机：

- minor gc： 虚拟机在进行minorGC之前会判断老年代最大的可用连续空间是否大于新生代的所有对象总空间,如果大于的话，直接执行minorGC。

- full gc:
  - 老年代空间不足：如果创建一个大对象，eden区中空间不足，直接保存到老年代中，当老年代空间不足时候，直接触发full gc；
  - 持久代空间不足
  - 统计YGC发生时晋升到老年代的平均总大小大于老年代的空闲空间
  - 显示调用System.gc()方法
  - YGC出现promotion failure

<img src="https://img-blog.csdnimg.cn/20190222222650784.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l2YV9icm90aGVy,size_16,color_FFFFFF,t_70" style="zoom:50%;" />

三、堆内存三个区的说明

- 新生代 ：刚创建的对象，在代码运行时一般都会持续不断地创建新的对象，这些新创建的对象有很多是局部变量，很快就会变成垃圾对象。这些对象被放在一块称为新生代的内存区域。新生代的特点是垃圾对象多，存活对象少。
- 老年代 ： 一些对象很早被创建了，经历了多次GC也没有被回收，而是一直存活下来。这些对象被放在一块称为老年代的区域。老年代的特点是存活对象多，垃圾对象少。
- 永久代 ：一些伴随虚拟机生命周期永久存在的对象，比如一些静态对象，常量等。这些对象被放在一块称为永久代的区域。永久代的特点是这些对象一般不需要垃圾回收，会在虚拟机运行过程中一直存活。（在Java1.7之前，方法区中存储的是永久代对象，Java1.7方法区的永久代对象移到了堆中，而在Java1.8永久代已经从堆中移除了，这块内存给了元空间。）

四、对象从新生代创建到老年代的历程：

1、说明：

- 对于新生代区域，每次GC都会有很多垃圾对象被回收，只有少量存活。因此采用复制回收算法，GC时把剩余很少的存活对象复制过去即可；
- 在新生代区域中，并不是按照1:1的比例来进行复制回收，而是按照8:1:1的比例分为了Eden、Survivor/s0、Survivor/s1三个区域；
- Eden区对外提供堆内存，新生对象都是在Eden区被创建的；
- Survivor区则为幸存者，即经历GC后仍然存活下来的对象会被放在该区域内；
- 老年代区域对象一般存活周期较长，每次GC时，存活的对象比较多，因此采用标记-整理算法

2、历程描述：

- 1、新生对象都是在Eden区被创建的；
- 2、当Eden区即将满是，则进行Minor GC(新生代GC)，把存活对象放入SurvivorA区，同时清空Eden区；
- 3、Eden区被清空后，继续对外提供堆内存；
- 4、当Eden区再次被填满，此时对Eden区和Survivor/s0区同时进行Minor GC(新生代GC)，把存活对象放入Survivor/s1区，此时同时清空Eden区和Survivor/s0区；
- 5、Eden区继续对外提供堆内存，并重复上述过程，即在 Eden 区填满后，把Eden区和某个Survivor区的存活对象放到另一个Survivor区；
- 6、当某个Survivor区被填满，且仍有对象未完全复制时，或者某些对象在反复Survive 15次左右时，则把这部分剩余对象放到老年代区域；
- 7、老年区也被填满时，进行Major GC（老年代GC），对老年代区域进行垃圾回收；
- 8、老年代区域对象一般存活周期较长，每次GC时，存活的对象比较多，GC时移动少量存活对象，不会产生内存碎片。

3、触发GC的类型

Java虚拟机会把每次触发GC的信息打印出来，可以根据日志来分析触发GC的原因。

- GC_FOR_MALLOC：表示是在堆上分配对象时内存不足触发的GC；
- GC_CONCURRENT：当我们应用程序的堆内存达到一定量，或者可以理解为快要满的时候，系统会自动触发GC操作来释放内存；
- GC_EXPpCIT：表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC；
- GC_BEFORE_OOM：表示是在准备抛OOM异常之前进行的最后努力而触发的GC。

五、七大垃圾回收器



